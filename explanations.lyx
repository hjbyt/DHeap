#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section*
Part I
\end_layout

\begin_layout Subsection*
Basis:
\end_layout

\begin_layout Standard
\begin_inset Formula $n$
\end_inset

 - size of the heap, 
\begin_inset Formula $d$
\end_inset

 - heap arity, 
\begin_inset Formula $h$
\end_inset

 - height of the heap.
\begin_inset Newline newline
\end_inset


\begin_inset Formula $d\geq2$
\end_inset

 is assumed.
 For 
\begin_inset Formula $d=1$
\end_inset

 the heap is degenerated, and the operations will take 
\begin_inset Formula $\Theta(n^{2})$
\end_inset

 at the worst case.
\begin_inset Newline newline
\end_inset

The amount of items in depth 
\begin_inset Formula $k$
\end_inset

 is at most 
\begin_inset Formula $d^{k}$
\end_inset

.
 Therefore:
\begin_inset Formula 
\begin{eqnarray*}
\sum_{k=1}^{h-1}d^{k} & \leq & n\Rightarrow\frac{d^{h}-1}{d-1}\leq n\Rightarrow\frac{d^{h}-1}{d}\leq n\Rightarrow d^{h}\leq nd+1\Rightarrow\\
h & \leq & \log_{d}(nd+1)\leq\log_{d}(nd+1)\leq\log_{d}(2nd)=\log_{d}(2)+\log_{d}(n)+1\leq\log_{d}(n)+2
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsection*
Analysis of heapifyDown:
\end_layout

\begin_layout Standard
It takes exactly 
\begin_inset Formula $d-1$
\end_inset

 comparisons to find the minimum child of a node, and 
\begin_inset Formula $1$
\end_inset

 comparison to determine if the current node should be swapped with it's
 minimum child.
 Therefore 
\begin_inset Formula $d$
\end_inset

 comparisons are done at each iteration, and there are at most 
\begin_inset Formula $k$
\end_inset

 iterations for a node at height 
\begin_inset Formula $k$
\end_inset

.
 Therefore for a call on a node of height 
\begin_inset Formula $k$
\end_inset

, there are at most 
\begin_inset Formula $dk$
\end_inset

 comparisons.
\end_layout

\begin_layout Subsection*
Analysis of arrayToHeap (implemented with heapify):
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $x$
\end_inset

 be the number of leaves in the heap.
 Then the number of nodes of height 
\begin_inset Formula $1$
\end_inset

 is 
\begin_inset Formula $\left\lceil \frac{x}{d}\right\rceil \leq\frac{x}{d}+1$
\end_inset

.
 The number of nodes of height 2 is 
\begin_inset Formula $\left\lceil \frac{\left\lceil \frac{x}{d}\right\rceil }{d}\right\rceil \leq\frac{\frac{x}{d}+1}{d}+1=\frac{x}{d^{2}}+\frac{1}{d}+1$
\end_inset

.
 Similarly the number of nodes of height 3 is not greater then 
\begin_inset Formula $\frac{x}{d^{3}}+\frac{1}{d^{2}}+\frac{1}{d}+1$
\end_inset

.
 Also, obviously 
\begin_inset Formula $x\leq n$
\end_inset

.
 It's easy to see that the number of nodes of height 
\begin_inset Formula $k$
\end_inset

 is not greater then 
\begin_inset Formula $\frac{n}{d^{k}}+2$
\end_inset

.
 From this, and from the analysis of heapifyDown, , the amount of comparisons
 done by arrayToHeap is bounded by:
\begin_inset Formula 
\begin{eqnarray*}
Comparisons & \leq & \sum_{k=1}^{h}dk\left(\frac{n}{d^{k}}+2\right)\stackrel{\mbox{*}}{\leq}\sum_{k=1}^{h}dk\cdot2\frac{n}{d^{k}}=2nd\sum_{k=1}^{h}\frac{k}{d^{k}}\leq2nd\sum_{k=0}^{\infty}\frac{k}{d^{k}}\\
 & = & 2nd\frac{d}{(d-1)^{2}}=2n\left(\frac{d}{(d-1)}\right)^{2}\leq8n=O(n)
\end{eqnarray*}

\end_inset

 Where the second transition is true for large enough 
\begin_inset Formula $n$
\end_inset

.
\begin_inset Newline newline
\end_inset

Also, 
\begin_inset Formula $\varOmega(n)$
\end_inset

 is an obvious lower bound for the comparisons made by heapify, as at least
 
\begin_inset Formula $n-1$
\end_inset

 comparisons are required to find a minimum item in an unordered list.
\begin_inset Newline newline
\end_inset

Therefore arrayToHeap executes 
\begin_inset Formula $\Theta(n)$
\end_inset

 comparisons.
\end_layout

\begin_layout Subsection*
Analysis of DHeapSort (i.e.
 
\begin_inset Formula $n$
\end_inset

 delete-min calls):
\end_layout

\begin_layout Standard
As each delete-min simply calls heapifyDown on the root, then from the analysis
 of heapifyDown, the number of comparisons is 
\begin_inset Formula $O(dh)=O(d(\log_{d}(n)+2))=O(d\log_{d}(n))=O(\frac{d}{\log(d)}\log(n))$
\end_inset

.
 Then the series of 
\begin_inset Formula $n$
\end_inset

 calls to delete-min are executed in 
\begin_inset Formula $O(\frac{d}{\log(d)}n\log(n))$
\end_inset

.
\color red

\begin_inset Newline newline
\end_inset

TODO: show why is this a tight bound TODO.
\color inherit

\begin_inset Newline newline
\end_inset

The seriese of 
\begin_inset Formula $n$
\end_inset

 delete-mins is more dominant than arrayToHeap, therefore the overall amount
 of comparisons at the worst-case is 
\begin_inset Formula $\Theta(\frac{d}{\log(d)}n\log(n))$
\end_inset

.
\end_layout

\begin_layout Subsection*
Measurements Explanation
\end_layout

\begin_layout Standard
Assuming the average case has a similar run-time complexity, the measurements
 can be explained:
\begin_inset Newline newline
\end_inset

The difference in performance between this sort and an optimal sort, e.g.
 merge-sort, is the term 
\begin_inset Formula $\frac{d}{\log(d)}$
\end_inset

.
 Looking at the function 
\begin_inset Formula $f(x)=\frac{x}{\log(x)}$
\end_inset

, we get 
\begin_inset Formula $f'(x)=\frac{\log(x)-1}{\log^{2}(x)}$
\end_inset

.
 Therefore 
\begin_inset Formula $f'(e)=0$
\end_inset

, and it is clear that 
\begin_inset Formula $x=e$
\end_inset

 is a global minimum for 
\begin_inset Formula $x\geq1$
\end_inset

.
 So in theory, an 
\begin_inset Formula $e$
\end_inset

-heap would have the lowest amount of comparisons.
 In practice 
\begin_inset Formula $3$
\end_inset

 is the closest integer to 
\begin_inset Formula $e$
\end_inset

, so it has the lowest amount of comparisons achievable using DHeapSort.
\end_layout

\begin_layout Section*
Part II
\end_layout

\begin_layout Subsection*
Analysis of heapifyUp:
\end_layout

\begin_layout Standard
When heapifyUp is called on an item at depth 
\begin_inset Formula $k$
\end_inset

, then at most 
\begin_inset Formula $k$
\end_inset

 comparisons and swaps are performed, as the item is only compared to it's
 parent.
\end_layout

\begin_layout Subsection*
Analysis of 
\begin_inset Formula $n$
\end_inset

 Decrease-Key calls:
\end_layout

\begin_layout Standard
The maximum depth of an item in a heap is 
\begin_inset Formula $h\leq\log_{d}(n)+2=O(\log_{d}(n))$
\end_inset

, therefore 
\begin_inset Formula $n$
\end_inset

 calls to Decrease-Key are bounded by 
\begin_inset Formula $O(n\log_{d}(n))=O(\frac{n\log(n)}{\log(d)})$
\end_inset


\begin_inset Newline newline
\end_inset

The bound is tight, as the following input shows:
\begin_inset Newline newline
\end_inset


\color red
TODO: the range of values can't be more than 1001! this makes the following
 example wrong, and may allow for a lower upper bound!
\color inherit
 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $n$
\end_inset

 items are inserted with the keys: 
\begin_inset Formula $2n+1,2n,2n-1,\ldots,n+1$
\end_inset

, and 
\begin_inset Formula $x=n+1$
\end_inset

.
 That way, at each iteration of Decrease-Key, the highest key becomes the
 lowest key, so it is must be 
\begin_inset Quotes eld
\end_inset

heapified up
\begin_inset Quotes erd
\end_inset

 from the deepest level to the root.
\begin_inset Newline newline
\end_inset

Therefore the amount of comparisons of in 
\begin_inset Formula $n$
\end_inset

 Decrease-Key calls at the worst case is 
\begin_inset Formula $\Theta(\frac{n\log(n)}{\log(d)})$
\end_inset

.
\begin_inset Newline newline
\end_inset

Note: if 
\begin_inset Formula $d\geq n$
\end_inset

 then the worst case is 
\begin_inset Formula $\Theta(n)$
\end_inset

, because 
\begin_inset Formula $\varOmega(n)$
\end_inset

 is an obvious lower bound.
\end_layout

\begin_layout Subsection*
Measurements Explanation
\end_layout

\begin_layout Standard
Assuming the average case has a similar run-time complexity, the measurements
 show that for 
\begin_inset Formula $x=100$
\end_inset

, 
\begin_inset Formula $x=1000$
\end_inset

, the number of comparisons indeed shrinks as 
\begin_inset Formula $d$
\end_inset

 grows, as expected.
\begin_inset Newline newline
\end_inset

The lower-bound for the best case is 
\begin_inset Formula $n-1$
\end_inset

 comparisons, in the case where no item changes its position (
\begin_inset Formula $-1$
\end_inset

 because the root item never needs to be heapified-up).
 That bound is indeed achieved for the case where 
\begin_inset Formula $x=1$
\end_inset

, because if a node's key is higher than it's parent, then decreasing it
 by 
\begin_inset Formula $1$
\end_inset

 will not make them swap.
 Because the heap is built by insertions and not via arrayToHeap, then if
 a node and it's parent have the same key, then the parent must have been
 inserted earlier (because nodes are inserted to the bottom of the heap
 and are heapified up).
 Therefore the parent's key will be decreased earlier, so there isn't a
 possibility for them to swap.
\end_layout

\end_body
\end_document
